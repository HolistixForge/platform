/**
 * Nginx Configuration Manager
 *
 * Manages dynamic nginx configurations for gateway allocation.
 * Creates/removes server blocks for org-specific gateways.
 */

import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { EPriority, log } from '@monorepo/log';

const execAsync = promisify(exec);

export class NginxManager {
  private envName: string;
  private envDir: string;
  private nginxGatewaysDir: string;
  private sslCertPath: string;
  private sslKeyPath: string;

  constructor() {
    this.envName = process.env.ENVIRONMENT_NAME || 'dev-001';
    this.envDir = `/root/.local-dev/${this.envName}`;
    this.nginxGatewaysDir = `${this.envDir}/nginx-gateways.d`;
    this.sslCertPath = `${this.envDir}/ssl-cert.pem`;
    this.sslKeyPath = `${this.envDir}/ssl-key.pem`;
  }

  /**
   * Create nginx config for organization gateway
   * Routes org-{uuid}.domain.local and *.org-{uuid}.domain.local to gateway HTTP port
   */
  async createGatewayConfig(orgId: string, httpPort: number): Promise<void> {
    const domain = process.env.DOMAIN || 'domain.local';
    const orgDomain = `org-${orgId}.${domain}`;
    const configPath = path.join(this.nginxGatewaysDir, `org-${orgId}.conf`);

    log(
      EPriority.Info,
      'NGINX',
      `Creating config for ${orgDomain} → 127.0.0.1:${httpPort}`
    );

    // Create nginx config (Stage 1: SSL termination, route to gateway)
    const nginxConfig = `# Gateway for organization ${orgId}
# Auto-generated by Ganymede
# DO NOT EDIT MANUALLY

upstream org-${orgId}-gw {
    server 127.0.0.1:${httpPort};
}

server {
    listen 443 ssl;
    server_name ${orgDomain} *.${orgDomain};

    ssl_certificate ${this.sslCertPath};
    ssl_certificate_key ${this.sslKeyPath};

    location / {
        proxy_pass http://org-${orgId}-gw;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;

        # WebSocket support
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
    }

    access_log ${this.envDir}/logs/gateway-${orgId}-access.log;
    error_log ${this.envDir}/logs/gateway-${orgId}-error.log;
}
`;

    try {
      // Ensure directory exists
      await fs.promises.mkdir(this.nginxGatewaysDir, { recursive: true });

      // Write config file
      await fs.promises.writeFile(configPath, nginxConfig, 'utf-8');

      log(EPriority.Info, 'NGINX', `✅ Config created: ${configPath}`);
    } catch (error: any) {
      log(
        EPriority.Error,
        'NGINX',
        `Failed to create config for org ${orgId}:`,
        error.message
      );
      throw new Error(`Nginx config creation failed: ${error.message}`);
    }
  }

  /**
   * Remove nginx config for organization gateway
   */
  async removeGatewayConfig(orgId: string): Promise<void> {
    const configPath = path.join(this.nginxGatewaysDir, `org-${orgId}.conf`);

    log(EPriority.Info, 'NGINX', `Removing config for org ${orgId}`);

    try {
      // Check if file exists
      try {
        await fs.promises.access(configPath, fs.constants.F_OK);
      } catch {
        log(
          EPriority.Info,
          'NGINX',
          `Config doesn't exist for org ${orgId}, nothing to remove`
        );
        return;
      }

      // Remove config file
      await fs.promises.unlink(configPath);

      log(EPriority.Info, 'NGINX', `✅ Config removed: ${configPath}`);
    } catch (error: any) {
      log(
        EPriority.Error,
        'NGINX',
        `Failed to remove config for org ${orgId}:`,
        error.message
      );
      // Don't throw - removal is best-effort
    }
  }

  /**
   * Reload nginx to apply configuration changes
   */
  async reloadNginx(): Promise<void> {
    log(EPriority.Info, 'NGINX', 'Testing and reloading nginx...');

    try {
      // Test configuration first
      const { stdout: testOutput, stderr: testError } = await execAsync(
        'sudo nginx -t 2>&1'
      );

      if (testError && !testOutput.includes('syntax is ok')) {
        log(EPriority.Critical, 'NGINX', `Config test failed: ${testError}`);
        throw new Error(`Nginx config test failed: ${testError}`);
      }

      // Reload nginx
      await execAsync('sudo service nginx reload');

      log(EPriority.Info, 'NGINX', '✅ Nginx reloaded successfully');
    } catch (error: any) {
      log(
        EPriority.Critical,
        'NGINX',
        `Failed to reload nginx:`,
        error.message
      );
      throw new Error(`Nginx reload failed: ${error.message}`);
    }
  }

  /**
   * List all gateway configs
   */
  async listConfigs(): Promise<string[]> {
    try {
      const files = await fs.promises.readdir(this.nginxGatewaysDir);
      return files.filter((f) => f.endsWith('.conf'));
    } catch (error: any) {
      log(
        EPriority.Critical,
        'NGINX',
        `Failed to list configs:`,
        error.message
      );
      return [];
    }
  }
}

// Export singleton instance
export const nginxManager = new NginxManager();
